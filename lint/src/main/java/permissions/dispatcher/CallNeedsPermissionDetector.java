package permissions.dispatcher;


import com.android.tools.lint.client.api.JavaParser;
import com.android.tools.lint.detector.api.*;
import com.intellij.openapi.util.Condition;
import com.intellij.psi.*;
import com.intellij.psi.util.PsiTreeUtil;
import lombok.ast.MethodInvocation;

import java.util.*;


public class CallNeedsPermissionDetector extends Detector implements Detector.JavaPsiScanner {
    public static final Issue ISSUE = Issue.create("CallNeedsPermission",
            "Call the corresponding \"withCheck\" method of the generated PermissionsDispatcher class instead",
            "Directly invoking a method annotated with @NeedsPermission may lead to misleading behaviour on devices running Marshmallow and up. Therefore, it is advised to use the generated PermissionsDispatcher class instead, which provides a \"withCheck\" method that safely handles runtime permissions.",
            Category.CORRECTNESS,
            7,
            Severity.ERROR,
            new Implementation(CallNeedsPermissionDetector.class, EnumSet.of(Scope.ALL_JAVA_FILES)));

    static List<String> generatedClassNames = new ArrayList<String>();

    @Override
    public JavaElementVisitor createPsiVisitor(JavaContext context) {
        if (context.getPhase() == 1) {
            // find out which class has RuntimePermissions
            return new AnnotationChecker(context);
        } else if (context.getPhase() == 2) {
            // find out which class call method with NeedPermission
            // exclude class with above with name XxxPermissionsDispatcher in the same package.
            return new MethodCallChecker(context);
        }
        return null;
    }

//    @Override
//    public AstVisitor createJavaVisitor(JavaContext context) {
//        if (context.getPhase() == 1) {
//            // find out which class has RuntimePermissions
//            return new AnnotationChecker(context);
//        } else if (context.getPhase() == 2) {
//            // find out which class call method with NeedPermission
//            // exclude class with above with name XxxPermissionsDispatcher in the same package.
//            return new MethodCallChecker(context);
//        }
//        return null;
//    }

    private static class AnnotationChecker extends JavaElementVisitor {
        private final JavaContext context;
        private Set<String> matchingAnnotationTypeNames;

        private AnnotationChecker(JavaContext context) {
            this.context = context;

            matchingAnnotationTypeNames = new HashSet<String>();
            matchingAnnotationTypeNames.add("RuntimePermissions");
            matchingAnnotationTypeNames.add("permissions.dispatcher.RuntimePermissions");
        }

        @Override
        public void visitAnnotation(PsiAnnotation annotation) {
            if (!context.isEnabled(ISSUE)) {
                super.visitAnnotation(annotation);
            }

            if (!matchingAnnotationTypeNames.contains(annotation.getQualifiedName()) {
                super.visitAnnotation(annotation);
            }

            PsiClass psiClass = (PsiClass) PsiTreeUtil.findFirstParent(annotation, true, new Condition<PsiElement>() {
                @Override
                public boolean value(PsiElement psiElement) {
                    return psiElement instanceof PsiClass;
                }
            });

            generatedClassNames.add(psiClass.getName() + "PermissionsDispatcher");
        }

//        @Override
//        public boolean visitAnnotation(Annotation node) {
//            if (!context.isEnabled(ISSUE)) {
//                return super.visitAnnotation(node);
//            }
//
//            String type = node.astAnnotationTypeReference().getTypeName();
//            if (!matchingAnnotationTypeNames.contains(type)) {
//                return super.visitAnnotation(node);
//            }
//
//            JavaParser.ResolvedNode resolvedNode = context.resolve(node.getParent());
//            if (resolvedNode instanceof JavaParser.ResolvedClass) {
//                generatedClassNames.add(resolvedNode.getName() + "PermissionsDispatcher");
//                // let's check method call!
//                context.requestRepeat(new CallNeedsPermissionDetector(), EnumSet.of(Scope.ALL_JAVA_FILES));
//            }
//            return super.visitAnnotation(node);
//        }
    }

    private class MethodCallChecker extends JavaElementVisitor {
        JavaContext javaContext;

        public MethodCallChecker(JavaContext context) {
            javaContext = context;
        }

//        @Override
//        public void visitClass(PsiClass aClass) {
//
//            generatedClassNames.contains(aClass.getName())
//
//        }
//
//        @Override
//        public boolean visitClassDeclaration(ClassDeclaration node) {
//            // Ignore a class that is generated by PermissionsDispatcher
//            return generatedClassNames.contains(javaContext.resolve(node).getName());
//        }


//        @Override
//        public void visitMethodCallExpression(PsiMethodCallExpression expression) {
//            PsiClass psiClass = (PsiClass) PsiTreeUtil.findFirstParent(expression, true, new Condition<PsiElement>() {
//                @Override
//                public boolean value(PsiElement psiElement) {
//                    return psiElement instanceof PsiClass;
//                }
//            });
//
//            if (!generatedClassNames.contains(psiClass)) return;
//
//            expression.get
//
//        }


        @Override
        public void visitMethod(PsiMethod method) {
            PsiClass psiClass = (PsiClass) PsiTreeUtil.findFirstParent(method, true, new Condition<PsiElement>() {
                @Override
                public boolean value(PsiElement psiElement) {
                    return psiElement instanceof PsiClass;
                }
            });

            if (psiClass == null || !generatedClassNames.contains(psiClass.getName())) return;


            // find annotation from method and compare

        }

//        @Override
//        public boolean visitMethodInvocation(MethodInvocation node) {
//            JavaParser.ResolvedNode resolved = javaContext.resolve(node);
//            if (!(resolved instanceof JavaParser.ResolvedMethod)) {
//                return super.visitMethodInvocation(node);
//            }
//            JavaParser.ResolvedMethod method = (JavaParser.ResolvedMethod) resolved;
//            JavaParser.ResolvedAnnotation annotation = method.getAnnotation("permissions.dispatcher.NeedsPermission");
//            if (annotation == null) {
//                return super.visitMethodInvocation(node);
//            }
//
//            javaContext.report(ISSUE, javaContext.getLocation(node), "Trying to access permission-protected method directly");
//            return super.visitMethodInvocation(node);
//        }
    }
}
